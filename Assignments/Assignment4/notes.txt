Building Tree:
- use a priority queue to have the lowest weights in front

Frequency Table:
- https://stackoverflow.com/questions/27727348/frequency-table-in-c
- https://stackoverflow.com/questions/29974332/read-through-chars-in-a-file-and-count-how-many-individual-letters-there-are-c

Using the application:
- need to utilize reading command line arguments
	- https://www.geeksforgeeks.org/command-line-arguments-in-c-cpp/

Input/output streams
- http://www.cplusplus.com/doc/tutorial/files/
- http://www.cplusplus.com/reference/fstream/ifstream/
- https://stackoverflow.com/questions/15736071/file-reading-class-c
- https://stackoverflow.com/questions/22390641/read-file-by-bits-c
	- char is 8 bits
	- for loop starts at 7
	- every loop it's going to shift right i bits and bitwise AND with that bit
- https://www.youtube.com/watch?v=z2Q1cvotLCk
	- REALLY GOOD YOUTUBE VID
- https://stackoverflow.com/questions/8461126/how-to-create-a-byte-out-of-8-bool-values-and-vice-versa
- http://courses.cs.vt.edu/~cs2604/fall00/binio.html
- http://www.cplusplus.com/forum/general/21018/
- https://stackoverflow.com/questions/33457974/outputting-a-binary-string-to-a-binary-file-in-c
- http://www.eecs.umich.edu/courses/eecs380/HANDOUTS/cppBinaryFileIO-2.html

Compressed File
- Needs to contain the # of bytes as the first thing in the file
	- this number refers to the number of bytes of the huffman tree


TODO:
- Convert algorithm for frequency counter into a class
- Create huffman tree class
	Private:
		BinaryNode root pointer
		weight


Overload operator:
    // Operator overload
    // Description: Less than or equals operator. Compares "this" BinaryNode object with "rhs" BinaryNode object.
	//              Returns true if frequency of "this" BinaryNode object is < frequency of "rhs" BinaryNode object.
    //              If weights are the same, return true.
    bool operator<=(const BinaryNode &rhs) const;

	// Operator overload
	// Description: Less than or equals operator. Compares "this" BinaryNode object with "rhs" BinaryNode object.
	//              Returns true if frequency of "this" BinaryNode object is < frequency of "rhs" BinaryNode object.
	//              If weights are the same, return true. Else return false.
	bool BinaryNode::operator<=(const BinaryNode &rhs) const
	{
		if (this->frequency < rhs.getFrequency())
		{
			return true;
		}
		else if(this->frequency == rhs.getFrequency())
		{
			return true;
		}
		else
		{
			return false;
		}

	}